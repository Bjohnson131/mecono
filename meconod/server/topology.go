package server

import (
	"fmt"
	"log"

	"github.com/jaksonkallio/mecono/meconod/network"
)

type Topology struct {
	Controllers   []*network.Controller
	Neighborships []Neighborship
}

type Neighborship struct {
	ControllerIndexA uint16
	ControllerIndexB uint16
}

func InitTopology(
	controllerCount uint16,
	neighborships []Neighborship,
) (*Topology, error) {
	controllers := make([]*network.Controller, controllerCount)

	for i := range controllers {
		controller, err := network.InitController(
			// "TN" is short for "Test Node"
			fmt.Sprintf("TN%04d", i),

			// MOTD
			"This node is used for testing 🛠️🛠️",

			// Port generated by an unused base value, iterated by which controller index we're creating.
			uint16(7600+i),
		)

		if err != nil {
			return nil, fmt.Errorf("could not initialize controller: %s", err)
		}

		controller.Start()
		controllers[i] = controller
	}

	// Create the topology struct.
	topology := &Topology{
		Controllers:   controllers,
		Neighborships: neighborships,
	}

	topology.Log(fmt.Sprintf("Initializing topology with %d controllers", len(topology.Controllers)))

	// Build neighborships of this new topology.
	topology.BuildNeighborships()

	return topology, nil
}

func (topology *Topology) BuildNeighborships() {
	topology.Log(fmt.Sprintf("Building %d neighborships", len(topology.Neighborships)))

	for _, neighborship := range topology.Neighborships {
		// Add A->B neighborship
		topology.Controllers[neighborship.ControllerIndexA].AddNeighbor(
			topology.Controllers[neighborship.ControllerIndexA].LookupNode(topology.Controllers[neighborship.ControllerIndexB].PublicKey),
			"127.0.0.1",
			"127.0.0.1",
			uint16(7600+neighborship.ControllerIndexB),
		)

		// Add B->A neighborship
		topology.Controllers[neighborship.ControllerIndexB].AddNeighbor(
			topology.Controllers[neighborship.ControllerIndexB].LookupNode(topology.Controllers[neighborship.ControllerIndexA].PublicKey),
			"127.0.0.1",
			"127.0.0.1",
			uint16(7600+neighborship.ControllerIndexA),
		)
	}
}

// Stops this server, which involves stopping all controllers.
func (topology *Topology) Stop() {
	for _, controller := range topology.Controllers {
		controller.Stop()
	}
}

func (topology *Topology) Log(msg string) {
	log.Printf("[TOPO] %s", msg)
}
